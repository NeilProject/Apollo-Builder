// Lic:
// Apollo Build
// Pack
// 
// 
// 
// (c) Jeroen P. Broks, 2021
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
// 
// Please note that some references to data like pictures or audio, do not automatically
// fall under this licenses. Mostly this is noted in the respective files.
// 
// Version: 21.07.18
// EndLic

using System;
using System.Collections.Generic;
using System.IO;
using TrickyUnits;
using UseJCR6;

namespace ApolloBuild {
	partial class Project {

		int PackErrors = 0;
		TJCRCreate ReleaseOut = null;

		void Pack(string pkgname, bool always = false) {
			var pkg = Package.Get(this, pkgname);
			var mustpack = always;
			var Blocks = new SortedDictionary<string, TJCRCreateBlock>();
			List<string> imports; if (pkgname == "MAIN") imports = Config.List("PROJECT", "IMPORT"); else imports = Config.List($"PACKAGE::{pkgname}", "IMPORT");
			QCol.Doing("Package", pkgname);
			mustpack = mustpack || pkg.added > 0 || pkg.deleted > 0 || pkg.forced > 0 || pkg.modified > 0 || MainClass.MkRelease;
			if (pkg.added > 0) QCol.Green($"Added: {pkg.added}\t");
			if (pkg.deleted > 0) QCol.Red($"Removed: {pkg.deleted}\t");
			if (pkg.modified > 0) QCol.Cyan($"Modified: {pkg.modified}\t");
			if (pkg.forced > 0) QCol.Magenta($"Forced: {pkg.forced}");
			if (!mustpack) {
				QCol.Cyan("No changes!\n");
				return;
			}
			Console.WriteLine("\n");
			if (!MainClass.MkRelease)
				Directory.CreateDirectory(OutputDir);
			TJCRCreate JOut = null;
			if (MainClass.MkRelease) {
				if (Config[$"PACKAGE::{pkgname}", "MergeOnRelease"] == "YES" || pkgname == "MAIN")
					JOut = ReleaseOut;
				else
					JOut = new TJCRCreate($"{OutputDir}/{pkg.Output}.jcr", Config["Project", "Compression"], Config["Identify", "Signature"]);
			} else {
				JOut = new TJCRCreate($"{OutputDir}/{pkg.Output}.jcr", Config["Project", "Compression"], Config["Identify", "Signature"]);
			}
			if (JOut.mystream == null) {
				QCol.QuickError($"JCR6 failed to create {pkg.Output}\n{JCR6.JERROR}");
				PackErrors++;
			}
			if (pkgname == "MAIN") {
				JOut.AddString(Identify.ToSource(), "ID/Identify.ini", Config["Project", "Compression"], "Apollo Builder", "File generated by Apollo Builder");
				foreach (var p in Package.Map.Keys) {
					var pk = Package.Map[p];
					if (p != "MAIN") {
						if ((!(Config[$"PACKAGE::{pkgname}", "MergeOnRelease"] == "YES" && MainClass.MkRelease)) && (Config[$"PACKAGE::{p}", "MergeOnRelease"] == "YES" || (!Yes($"PACKAGE::{p}", "Optional", $"Is package {p} optional"))))
							JOut.Require($"{pk.Output}.jcr", Config["Identify", "Signature"]);
						else
							JOut.Import($"{pk.Output}.jcr");
					}
				}
			}
			foreach (var G in Gathered) {
				if (G.Package == pkgname) {
					var JCRMerge = false;
					if (JCR6.Recognize(G.OriginalFile) != "NONE") {
						JCRMerge = Yes("JCR6", "GlobalMerge", "Do you want to merge all JCR6 files in this project");
						JCRMerge = JCRMerge || Yes($"PACKAGE::{pkgname}", "JCR6MERGE", "Do you want to merge JCR6 found in this package");
					}
					if (JCRMerge) {
						var Jmrg = JCR6.Dir(G.OriginalFile);
						Verbose.Doing("  Merging", G.OriginalFile);
						if (Jmrg == null) {
							QCol.QuickError($"Reading the directory of {G.OriginalFile} failed");
							QCol.Magenta($"{JCR6.JERROR}\n");
							PackErrors++;
						} else {
							foreach (var e in Jmrg.Entries.Values) {
								QCol.Doing("  Adding", "", "");
								QCol.Magenta(G.OriginalFile);
								QCol.White("/");
								QCol.Cyan($"{e.Entry}\r");
								var EA = e.Author;
								var EN = e.Notes;
								if (EA == "" && EN == "" && Yes("JCR6", "MergePackageNotes", "No author and notes found. Should I just copy the package data whenever this happens")) {
									EA = G.Author;
									EN = G.Notes;
								}
								//Console.WriteLine($"DEBUG: {G.OriginalFile} - {G.Block} ");
								if (G.Block == "") {
									JOut.AddBytes(Jmrg.JCR_B(e.Entry), $"{G.StoreAs}/{e.Entry}", Config["Project", "Compression"], EA, EN);
									if (!JOut.Entries.ContainsKey(($"{G.StoreAs}/{e.Entry}").ToUpper())) {
										QCol.Red("  Failure\n");
										QCol.QuickError(JCR6.JERROR);
										PackErrors++;
									} else {
										var E = JOut.Entries[($"{G.StoreAs}/{e.Entry}").ToUpper()];
										if (E.Storage == "Store") {
											QCol.Green("     Stored\n");
										} else {
											QCol.Magenta(qstr.Right($"   {E.Ratio}", 4) + " ");
											QCol.Green($"{E.Storage}\n");
										}
									}
								} else {
									if (!Blocks.ContainsKey(G.Block)) Blocks[G.Block] = new TJCRCreateBlock(JOut, Config["Project", "Compression"]);
									Blocks[G.Block].AddBytes(Jmrg.JCR_B(e.Entry), $"{G.StoreAs}/{e.Entry}", EA, EN);
									if (!JOut.Entries.ContainsKey(($"{G.StoreAs}/{e.Entry}").ToUpper())) {
										QCol.Red("  Failure\n");
										QCol.QuickError(JCR6.JERROR);
										PackErrors++;
									} else {
										QCol.DarkGray("   To Block\n");
									}
								}
							}
						}
					} else {
						QCol.Doing("  Adding", G.OriginalFile, "\r");
						if (G.Block == "") {
							JOut.AddFile(G.OriginalFile, G.StoreAs, Config["Project", "Compression"], G.Author, G.Notes);
							if (!JOut.Entries.ContainsKey(G.StoreAs.ToUpper())) {
								QCol.Red("  Failure\n");
								QCol.QuickError(JCR6.JERROR);
								PackErrors++;
							} else {
								var E = JOut.Entries[G.StoreAs.ToUpper()];
								if (E.Storage == "Store") {
									QCol.Green("     Stored\n");
								} else {
									QCol.Magenta(qstr.Right($"   {E.Ratio}", 4) + " ");
									QCol.Green($"{E.Storage}\n");
								}
							}
						} else {
							if (!Blocks.ContainsKey(G.Block)) Blocks[G.Block] = new TJCRCreateBlock(JOut, Config["Project", "Compression"]);
							Blocks[G.Block].AddFile(G.OriginalFile, G.StoreAs, G.Author, G.Notes);
							if (!JOut.Entries.ContainsKey(G.StoreAs.ToUpper())) {
								QCol.Red("  Failure\n");
								QCol.QuickError(JCR6.JERROR);
								PackErrors++;
							} else {
								QCol.DarkGray("   To Block\n");
							}
						}
					}
				}
			}
			foreach (var BLK in Blocks) {
				QCol.Doing("  Adding", $"Block: {BLK.Key}", "\r");
				BLK.Value.Close();
				QCol.Magenta(qstr.Right($"  {BLK.Value.Ratio}%", 4) + " ");
				QCol.Green($"{BLK.Value.Storage}\n");
			}
			foreach (string imp in imports) {
				QCol.Doing("Import", imp);
				if (MainClass.MkRelease) {
					if (Yes($"PACKAGE::{pkgname}", $"CopyImport_PRF::{imp}", "Do you want to copy in this import file from its original location into the release")) {
						var tgt = qstr.StripDir(imp);
						var ori = Dirry.AD(Ask($"PACKAGE::{pkgname}", $"COPYIMPORT_ORI::{imp}", "Give me the full path of the original", $"{Config["Project", "OUTPUT::DEBUG"]}/{tgt}"));
						QCol.Doing("Copying", $"{ori} => {tgt}");
						try {
							File.Copy(ori, $"{Dirry.AD(Config["Project", "OUTPUT::RELEASE"])}/{Dirry.AD(tgt)}");
							JOut.Import(tgt);
						} catch (Exception E) {
							QCol.QuickError($"{E.Message}");
							PackErrors++;
						}
					} else JOut.Import(imp);
				} else
					JOut.Import(imp);
			}
			if (Config.HasList($"PACKAGE::{pkgname}", "ALIAS")) {
				foreach (var alline in Config.List($"PACKAGE::{pkgname}", "ALIAS")) {
					string[] doit = new string[2];
					int addto = 0;
					bool goed = true;
					if (alline == "") { }// should never happen
					else if (alline.Length < 6) { QCol.QuickError("Alias line too short to be taken seriously"); PackErrors++; } else {
						int pos = 0;
						do {
							if (pos < alline.Length - 4 && qstr.Mid(alline, pos + 1, 4) == " => ") {
								if (addto > 0) {
									QCol.QuickError("Syntax error! Dupe => in alias!"); PackErrors++; goed = false;
								} else {
									addto = 1;
									pos += 4;
								}
							} else {
								doit[addto] += alline[pos];
								pos++;
							}
						} while (goed && pos < alline.Length);
						if (addto == 0) {
							QCol.QuickError("Syntax error! => not found!"); PackErrors++; goed = false;
						} else if (goed) {
							QCol.Doing("Alias", doit[0], "\t");
							QCol.Doing("to", doit[1]);
							JOut.Alias(doit[0].Trim(), doit[1].Trim());
						}
					}
				}
			} else {
				Verbose.Printf("There were no aliases!\n");
			}
			if (JOut != ReleaseOut)
				JOut.Close();
		}

	}
}