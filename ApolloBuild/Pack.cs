// Lic:
// Apollo Build
// Pack
// 
// 
// 
// (c) Jeroen P. Broks, 2021
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
// 
// Please note that some references to data like pictures or audio, do not automatically
// fall under this licenses. Mostly this is noted in the respective files.
// 
// Version: 21.06.07
// EndLic
???
using System;
using System.Collections.Generic;
using System.IO;
using TrickyUnits;
using UseJCR6;

namespace ApolloBuild {
    partial class Project {

        int PackErrors = 0;

        void Pack(string pkgname,bool always=false) {
            var pkg= Package.Get(this,pkgname);
            var mustpack = always;
            List<string> imports; if (pkgname == "MAIN") imports = Config.List("PROJECT", "IMPORT"); else imports = Config.List($"PACKAGE::{pkgname}", "IMPORT");
            QCol.Doing("Package", pkgname);
            mustpack = mustpack || pkg.added > 0 || pkg.deleted > 0 || pkg.forced > 0 || pkg.modified > 0;
            if (pkg.added > 0) QCol.Green($"Added: {pkg.added}\t");
            if (pkg.deleted > 0) QCol.Red($"Removed: {pkg.deleted}\t");
            if (pkg.modified > 0) QCol.Cyan($"Modified: {pkg.modified}\t");
            if (pkg.forced > 0) QCol.Magenta($"Forced: {pkg.forced}");
            if (!mustpack) {
                QCol.Cyan("No changes!\n");
                return;
            }
            Console.WriteLine("\n");
            Directory.CreateDirectory(OutputDir);
            var JOut = new TJCRCreate($"{OutputDir}/{pkg.Output}.jcr", Config["Project", "Compression"],Config["Identify", "Signature"]);
            if (JOut.mystream==null) {
                QCol.QuickError($"JCR6 failed to create {pkg.Output}\n{JCR6.JERROR}");
                PackErrors++;
            }
            if (pkgname == "MAIN") {
                JOut.AddString(Identify.ToSource(), "ID/Identify.ini", Config["Project", "Compression"], "Apollo Builder", "File generated by Apollo Builder");
                foreach (var p in Package.Map.Keys) {
                    var pk = Package.Map[p];
                    if (p != "MAIN") {
                        if (Config[$"PACKAGE::{p}", "MergeOnRelease"] == "YES" || (!Yes($"PACKAGE::{p}", "Optional","Is package {p} optional")))
                            JOut.Require($"{pk.Output}.jcr", Config["Identify", "Signature"]);
                        else
                            JOut.Import($"{pk.Output}.jcr");
                    }
                }
            }
            foreach(var G in Gathered) {
                if (G.Package == pkgname) {
                    var JCRMerge = false;
                    if (JCR6.Recognize(G.OriginalFile) != "NONE") {
                        JCRMerge = Yes("JCR6", "GlobalMerge", "Do you want to merge all JCR6 files in this project");
                        JCRMerge = JCRMerge || Yes($"PACKAGE::{pkgname}", "JCR6MERGE", "Do you want to merge JCR6 found in this package");
                    }
                    if (JCRMerge) {
                        var Jmrg = JCR6.Dir(G.OriginalFile);
                        Verbose.Doing("  Merging", G.OriginalFile);
                        foreach(var e in Jmrg.Entries.Values) {
                            QCol.Doing("  Adding", "","");
                            QCol.Magenta(G.OriginalFile);
                            QCol.White("/");
                            QCol.Cyan($"{e.Entry}\r");
                            var EA = e.Author;
                            var EN = e.Notes;
                            if (EA=="" && EN=="" && Yes("JCR6","MergePackageNotes","No author and notes found. Should I just copy the package data whenever this happens")) {
                                EA = G.Author;
                                EN = G.Notes;
                            }
                            JOut.AddBytes(Jmrg.JCR_B(e.Entry), $"{G.StoreAs}/{e.Entry}", Config["Project", "Compression"], EA, EN);
                            if (!JOut.Entries.ContainsKey(($"{G.StoreAs}/{e.Entry}").ToUpper())) {
                                QCol.Red("  Failure\n");
                                QCol.QuickError(JCR6.JERROR);
                                PackErrors++;
                            } else {
                                var E = JOut.Entries[($"{G.StoreAs}/{e.Entry}").ToUpper()];
                                if (E.Storage == "Store") {
                                    QCol.Green("     Stored\n");
                                } else {
                                    QCol.Magenta(qstr.Right($"   {E.Ratio}", 4) + " ");
                                    QCol.Green($"{E.Storage}\n");
                                }
                            }
                        }
                    } else {
                        QCol.Doing("  Adding", G.OriginalFile, "\r");
                        JOut.AddFile(G.OriginalFile, G.StoreAs, Config["Project", "Compression"], G.Author, G.Notes);
                        if (!JOut.Entries.ContainsKey(G.StoreAs.ToUpper())) {
                            QCol.Red("  Failure\n");
                            QCol.QuickError(JCR6.JERROR);
                            PackErrors++;
                        } else {
                            var E = JOut.Entries[G.StoreAs.ToUpper()];
                            if (E.Storage == "Store") {
                                QCol.Green("     Stored\n");
                            } else {
                                QCol.Magenta(qstr.Right($"   {E.Ratio}", 4) + " ");
                                QCol.Green($"{E.Storage}\n");
                            }
                        }
                    }
                }
            }
            foreach (string imp in imports) {
                JOut.Import(imp);
                QCol.Doing("Import", imp);
            }
            if (Config.HasList($"PACKAGE::{pkgname}","ALIAS")) { 
                foreach(var alline in Config.List($"PACKAGE::{pkgname}", "ALIAS")) {
                    string[] doit = new string[2];
                    int addto = 0;
                    bool goed = true;
                    if (alline == "") { }// should never happen
                    else if(alline.Length<6) { QCol.QuickError("Alias line too short to be taken seriously"); PackErrors++; }
                    else {
                        int pos = 0;
                        do {
                            if (pos<alline.Length-4 && qstr.Mid(alline, pos + 1, 4) == " => ") {
                                if (addto > 0) {
                                    QCol.QuickError("Syntax error! Dupe => in alias!"); PackErrors++; goed = false;
                                } else {
                                    addto = 1;
                                    pos += 4;
                                }
                            } else {
                                doit[addto] += alline[pos];
                                pos++;
                            }
                        } while (goed && pos < alline.Length);
                        if (addto == 0) {
                            QCol.QuickError("Syntax error! => not found!"); PackErrors++; goed = false;
                        } else if (goed) {
                            QCol.Doing("Alias", doit[0], "\t");
                            QCol.Doing("to", doit[1]);
                            JOut.Alias(doit[0].Trim(), doit[1].Trim());
                        }
                    }
                }
            } else {
                Verbose.Printf("There were no aliases!\n");
            }
            JOut.Close();
        }

    }
}